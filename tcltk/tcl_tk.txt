A short introduction into tcl/tk
--------------------------------
# set varName with value "val" and returns "val"
set varName val 

# TCL Array are assoziative and "array" with index "test" were set to "val"
set array(test) val

Text in "" will be substituted if not escaped
Text in {} will not be substituted

expr command should every time set in {}, because:

	% set userinput {[puts DANGER!]}
	[puts DANGER!]
	% expr $userinput == 1
	DANGER!
	0
	% expr {$userinput == 1}
	0

switch can evaluate strings with pattern matches too
	- glob style pattern using * any number of chars
	- Option "-exact" searching literal strings
	- Option "-regexp" searching against regex

	A Switch without Braces but with "\" Line Escaping will support
	variable substitution:
		
		#substitution won't work
		switch $test {
			1 -
			$bla {
			}
		}
		#substitutions works
		switch $test\
			$bla {
				...
			}\
			...
		

procs are handlin return for returning value or the result of the last command
also you can made some functions more easy:

	proc sum {arg1 arg2} {
		set x [expr {$arg1 + $arg2}]
		return $x
	}

	proc sum1 { arg1 arg2 } {
		set x [expr {$arg1 + $arg2}]
	}

	proc sum2 { arg1 arg2 } {
		expr {$arg1 + $arg2}
	}

	puts "sum 2 + 3: [sum 2 3]"
	puts "sum1 2 + 3: [sum1 2 3]"
	puts "sum2 2 + 3: [sum2 2 3]"

procs default params
	proc test { a { b 3} {c 7}} ....

procs varg args(have to be the last declared one)
	proc test {args}....foreach arg $args.....

in Combination this works
	proc test { a {default1 3} {default2 2} args } {....}


-- Lists
list 	{{i1} {i2} {i3}}; # creation of list with items
split	"test.bla.blub.foo.bar" ".";# created list with split
lindex	$myList 1; # get index 1 of list
lindex  $myList 1 2 3;# multiple index possible at list of list of list...

set x "a b c d e f"
lindex $x 2;# results in 'c'

-- arrays 
can only be accessed via "pointer" to a proc with the comman upvar.


--example class

    ::oo::class create range {
        variable max 
        variable current

        constructor {upto} {
            my max $upto
        }

        destructor {
            puts "Destroying [self]"
        }

        method max {upto} {
            variable max 
            variable current
            set max     $upto
            set current -1
        }

        method next {varName} {
            upvar $varName var
            incr current
            set var $current
            if { $var < $max } {
                return 1
            } else {
                return 0
            }
        }
    }
	
  # changes o class from putside
  ::oo::define range method reset {} {set current -1}

  #Inheritance
    ::oo::class create newrange {
        superclass range
        method reset {} {set current -1}
    }
  
  # cloning objects 
    ::oo::copy xrange yrange
  
  # object definitions
    ::oo::objdefine $yrange {
        method reset {} {
            my variable current
            puts "resetting ..."
            set current -1
        }
    }

If the method's name starts with an upper case letter it is private.
If the method's name starts with a lower case letter it is public.

# you have to destroy objects, otherwise they life long the interpreter is
running or you call despproy
    myobj destroy

